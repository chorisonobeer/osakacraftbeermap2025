<documents>
<document index="1">
<source>package.json</source>
<document_content>
{
  "name": "geolonia-pwa",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.8.2",
    "@emotion/styled": "^11.8.1",
    "@mapbox/geojson-extent": "^1.0.1",
    "@material-ui/core": "^5.0.0-beta.5",
    "@testing-library/jest-dom": "^5.16.2",
    "@testing-library/react": "^12.1.4",
    "@testing-library/user-event": "^13.5.0",
    "@turf/turf": "^6.5.0",
    "@types/jest": "^27.4.1",
    "@types/node": "^17.0.22",
    "@types/react": "^17.0.41",
    "@types/react-dom": "^17.0.14",
    "chalk": "^5.0.1",
    "csv-parse": "^4.8.8",
    "icon-gen": "^3.0.0",
    "next-qrcode": "^2.5.1",
    "papaparse": "^5.4.1",
    "pwa-asset-generator": "^6.0.6",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-icons": "^4.3.1",
    "react-infinite-scroll-component": "^6.1.0",
    "react-router-dom": "^6.2.2",
    "react-scripts": "^5.0.1",
    "react-select": "^5.2.2",
    "react-share": "^4.4.0",
    "react-stars": "^2.2.5",
    "react-swipeable": "^7.0.2",
    "typescript": "~4.6.2"
  },
  "scripts": {
    "start": "node bin/config.js && react-scripts start",
    "build": "node bin/config.js && react-scripts build",
    "build:assets": "pwa-asset-generator public/logo.svg ./public/ --index ./public/index.html --manifest ./public/manifest.json --favicon true",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "homepage": ".",
  "eslintConfig": {
    "extends": "react-app"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11",
    "@types/lodash": "^4.17.15",
    "@types/papaparse": "^5.3.14",
    "@types/react-infinite-scroller": "^1.2.3",
    "@types/react-router-dom": "^5.3.3",
    "@types/react-stars": "^2.2.1",
    "axios": "^0.26.1",
    "node-fetch": "2",
    "sass": "^1.49.9",
    "stream-browserify": "^3.0.0",
    "yaml": "^1.10.2"
  }
}

</document_content>
</document>
<document index="2">
<source>README.md</source>
<document_content>
# Geolonia PWAマップ

## Geolonia PWAマップ について

Geolonia PWA は、GitHub と Google Sheets を使って、素早く PWA の地図アプリが作れるテンプレートです。

## フォーク

まず、以下のリポジトリをフォークしてください。
https://github.com/geoloniamaps/pwamap


## サイト全体の設定

`config.yml` を書き換えることでサイト全体の設定を変更できます。

設定の例:
```
title: Geolonia PWAマップ
description: Google スプレッドシートを更新するだけでオリジナルの地図アプリを作成できる\n「Geolonia PWAマップ」
data_url: https://docs.google.com/spreadsheets/d/1_m8s4P5tdSeam3nzC5ruSfuvtSejQKEX1FiBeOWJN3E/pub?gid=1957425126&single=true&output=csv
form_url: ""
logo_image_url: https://geoloniamaps.github.io/pwamap/icon-pwamap.svg
background_image_url: https://geoloniamaps.github.io/pwamap/geolonia_bgimage_1920_1080.png
primary_color: "#d2691e"
orderby: distance
```

- `title`: サイトのタイトルです。
- `description`: サイトの概要文です。
- `data_url`: アプリで読み込む CSV データまでの URL を記述してください。SSL は必須です。
- `form_url`: データの追加/更新用の申請フォームの URL を記述してください。
- `logo_image_url`: PCで表示した時のロゴ画像の URL を記述してください。
- `background_image_url`: PCで表示した時の背景画像の URL を記述してください。
- `primary_color`: サイトのテーマカラーを記述してください。（例: `#d2691e`）
- `orderby`: 一覧ページのデータの並び順を指定します。`distance` で距離順に並び替えます。`time` で新着順に並び替えます。

## スポットデータについて

スポットは CSV 以下の方法でスポットデータファイルを作成して、`config.yml` にその CSV までの URL を設定してください。  

- `緯度`、`経度`、`スポット名`、`カテゴリ` のみが必須で、これらのどれか一つでも入力されていないとアプリ上には表示されません。
- なお、データは AJAX で常時読み込んでいますので、CSV が編集されるとほぼ同時にアプリ側にも反映されると考えてください。（キャッシュで多少タイムラグがあります。）

### Google スプレッドシートを使う方法
以下のスプレッドシートをコピーしてください。

https://docs.google.com/spreadsheets/d/1_m8s4P5tdSeam3nzC5ruSfuvtSejQKEX1FiBeOWJN3E/edit?usp=sharing

次に共有設定を行ってください。

<img width="80%" alt="" src="https://github.com/user-attachments/assets/8a2f5031-ae90-4dd4-a2f1-4c2a1db70f42">


Webへの公開設定で、「スポットデータ」シートを選択し、「カンマ区切り（.csv）」を選択して公開して下さい。


<img width="80%" alt="" src="https://github.com/user-attachments/assets/7c437ceb-21a3-4f06-9abc-5f798c7ba44a">

公開をクリックし、表示された URL を `config.yml` の `data_url` に指定して下さい。  
GitHub Pages の設定をし、 コミットするとデータが反映されます。

## 開発

[Geolonia PWA マップ ユーザーマニュアル](https://blog.geolonia.com/2022/05/17/pwamap-manual-setup.html) の手順を実行、その後以下のコマンドを実行して下さい。

```shell
$ git clone git@github.com:geoloniamaps/pwa.git
$ cd pwa
$ npm install
$ npm start
```

下の URL にアクセスして下さい。開発サーバーが立ち上がります。

`http://localhost:3000/#/`


## 注意事項
このプログラムは自由にカスタマイズ可能ですが、利用についてはサポート対象外となります。


</document_content>
</document>
<document index="3">
<source>tsconfig.json</source>
<document_content>
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": false
  },
  "include": [
    "src"
  ]
}
</document_content>
</document>
<document index="4">
<source>bin\config.js</source>
<document_content>
/**
 * @file YAML 形式の設定ファイルをパースし 環境変数として react-scripts に読み込ませる
 */

const fs = require("fs");
const YAML = require("yaml");
const path = require("path")

const srcConfigFilePath = path.join(process.cwd(), "/config.yml");
const distConfigFilePath = path.join(process.cwd(), "/src/config.json");

let yamlText;
try {
  yamlText = fs.readFileSync(srcConfigFilePath).toString();
} catch (error) {
  process.stderr.write(`${srcConfigFilePath} が存在しません。\n`);
  process.exit(1);
}

let config;
try {
  config = YAML.parse(yamlText);
} catch (error) {
  process.stderr.write(
    `${srcConfigFilePath} は正しい YAML 形式である必要があります。\n`
  );
  process.exit(2);
}

if (!config) {
  process.stderr.write(
    `${srcConfigFilePath} は正しい YAML 形式である必要があります。\n`
  );
  process.exit(3);
}

const envText =
  Object.keys(config)
    // オブジェクト等は環境変数として出力しない
    .filter((key) => typeof config[key] === "string" || typeof config[key] === "number")
    .map((key) => `REACT_APP_${key.toUpperCase()}="${config[key]}"`)
    .join("\n") + "\n";

// 全ての設定は src/config.json として出力する
fs.writeFileSync(distConfigFilePath, JSON.stringify(config, null, 2));

fs.writeFileSync(path.join(process.cwd() , '.env'), envText)
process.exit(0);

</document_content>
</document>
<document index="5">
<source>public\index.html</source>
<document_content>
<!DOCTYPE html>
<html lang="ja">
  <head>
    <style>
      :root {
        --primary-color: %REACT_APP_PRIMARY_COLOR%;
        --background-image: url(%REACT_APP_BACKGROUND_IMAGE_URL%);
      }
    </style>
    <meta charset="utf-8">
    <link href="./style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/earlyaccess/nicomoji.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,maximum-scale=1,viewport-fit=cover,minimal-ui,height=device-height">
    <meta name="theme-color" content="#FFFFFF">
    <meta name="description" content="%REACT_APP_TITLE%">
    <meta name="apple-mobile-web-app-title" content="%REACT_APP_TITLE%">
    <meta name="twitter:card" content="summary_large_image">
    <meta property="og:url" content="%REACT_APP_HOMEPAGE_URL%">
    <meta property="og:title" content="%REACT_APP_TITLE%">
    <meta property="og:image" content="%REACT_APP_HOMEPAGE_URL%apple-splash-1136-640.jpg">
    <meta property="og:type" content="website">
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json">
    <title>%REACT_APP_TITLE%</title>
    <link rel="icon" type="image/png" sizes="196x196" href="favicon-196.png">
    <link rel="apple-touch-icon" href="apple-icon-180.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="apple-touch-startup-image" href="apple-splash-2048-2732.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2732-2048.jpg" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1668-2388.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2388-1668.jpg" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1536-2048.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2048-1536.jpg" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1668-2224.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2224-1668.jpg" media="(device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1620-2160.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2160-1620.jpg" media="(device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1284-2778.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2778-1284.jpg" media="(device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1170-2532.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2532-1170.jpg" media="(device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1125-2436.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2436-1125.jpg" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1242-2688.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2688-1242.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-828-1792.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-1792-828.jpg" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-1242-2208.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-2208-1242.jpg" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-750-1334.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-1334-750.jpg" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
    <link rel="apple-touch-startup-image" href="apple-splash-640-1136.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="apple-splash-1136-640.jpg" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)">
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!-- 追加: Portal 用の要素 -->
    <div id="modal-root"></div>
    <script type="text/javascript" src="https://cdn.geolonia.com/v1/embed?geolonia-api-key=YOUR-API-KEY"></script>
  </body>
</html>

</document_content>
</document>
<document index="6">
<source>public\manifest.json</source>
<document_content>
{
  "short_name": "Geolonia PWA",
  "name": "Geolonia PWA",
  "icons": [
    {
      "src": "manifest-icon-192.maskable.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "manifest-icon-192.maskable.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "manifest-icon-512.maskable.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "manifest-icon-512.maskable.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#FFFFFF",
  "background_color": "#ffffff"
}
</document_content>
</document>
<document index="7">
<source>public\style.css</source>
<document_content>
html, body, #root
{
  width: 100%;
  height: 100%;
  -webkit-text-size-adjust: none;
}

#root
{
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background: none;
}

#root > .loader
{
  width: 192px;
  font-size: 32px;
  text-align: center;
}

img
{
  max-width: 100%;
}

@media only screen and (max-width: 960px) {
  .github-fork-ribbon
  {
    display: none;
  }

  #root
  {
    background: none !important;
  }

}

</document_content>
</document>
<document index="8">
<source>src\App.tsx</source>
<document_content>
/* 
Full Path: /src/App.tsx
Last Modified: 2025-02-28 17:45:00
*/

import React from "react";
import { Routes, Route } from "react-router-dom";
import "./App.scss";

import Home from './App/Home';
import List from './App/List';
import AboutUs from './App/AboutUs';
import Category from './App/Category';
import Images from './App/Images';

import Tabbar from './App/Tabbar';
import config from "./config.json";
import Papa from 'papaparse';
import { GeolocationProvider } from './context/GeolocationContext';

const sortShopList = async (shopList: Pwamap.ShopData[]) => {
  // 新着順にソート
  return shopList.sort((item1, item2) => {
    return Date.parse(item2['タイムスタンプ']) - Date.parse(item1['タイムスタンプ']);
  });
}

const App = () => {
  const [shopList, setShopList] = React.useState<Pwamap.ShopData[]>([]);

  React.useEffect(() => {
    fetch(config.data_url)
      .then((response) => {
        return response.ok ? response.text() : Promise.reject(response.status);
      })
      .then((data) => {
        Papa.parse(data, {
          header: true,
          complete: (results) => {
            const features = results.data;
            const nextShopList: Pwamap.ShopData[] = [];
            for (let i = 0; i < features.length; i++) {
              const feature = features[i] as Pwamap.ShopData;
              if (!feature['緯度'] || !feature['経度'] || !feature['スポット名']) continue;
              if (!feature['緯度'].match(/^[0-9]+(\.[0-9]+)?$/)) continue;
              if (!feature['経度'].match(/^[0-9]+(\.[0-9]+)?$/)) continue;
              const shop = { index: i, ...feature };
              nextShopList.push(shop);
            }
            sortShopList(nextShopList).then((sortedShopList) => {
              setShopList(sortedShopList);
            });
          }
        });
      });
  }, []);

  return (
    <GeolocationProvider>
      <div className="app">
        <div className="app-body">
          <Routes>
            <Route path="/" element={<Home data={shopList} />} />
            <Route path="/list" element={<List data={shopList} />} />
            <Route path="/category" element={<Category data={shopList} />} />
            <Route path="/images" element={<Images data={shopList} />} />
            <Route path="/about" element={<AboutUs />} />
          </Routes>
        </div>
        <div id="modal-root"></div>
        <div className="app-footer">
          <Tabbar />
        </div>
      </div>
    </GeolocationProvider>
  );
}

export default App;

</document_content>
</document>
<document index="9">
<source>src\config.json</source>
<document_content>
{
  "title": "佐和田料飲店マップ2025",
  "description": "新潟県佐渡市佐和田町料飲店組合加盟店のMAPです",
  "data_url": "https://docs.google.com/spreadsheets/d/e/2PACX-1vRvUHoy7wWdYt4WjEy3fNyD2P89GtkTzuw45ILKKsDMnxQK_MpScN_8X98LFGC7Eoeguyk0ybGVUblZ/pub?gid=1957425126&single=true&output=csv",
  "form_url": null,
  "logo_image_url": "/logo.svg",
  "background_image_url": "/back.jpg",
  "primary_color": "#00A0E6",
  "orderby": "distance"
}
</document_content>
</document>
<document index="10">
<source>src\Container.tsx</source>
<document_content>
import React from "react";

import App from './App'
import About from './About'
import './Container.scss'

function Content() {
  return (
    <div className="outer-container">
      <div className="inner-container">
        <About />
        <App />
      </div>
    </div>
  );
}

export default Content;

</document_content>
</document>
<document index="11">
<source>src\geolocation.ts</source>
<document_content>
export const askGeolocationPermission = () => {
  return new Promise<Pwamap.LngLat | null>((resolve, reject) => {

    if(!window.navigator.geolocation || !window.navigator.geolocation.getCurrentPosition) {
      resolve(null)
    }

    window.navigator.geolocation.getCurrentPosition(
      (pos) => {
        const lat = pos.coords.latitude
        const lng = pos.coords.longitude
        resolve([lng, lat])
      },
      (error) => {
        resolve(null)
      },
      {
        enableHighAccuracy: true,
        timeout: 10000,
        maximumAge: 0
      }
    )
  })
}

</document_content>
</document>
<document index="12">
<source>src\global.d.ts</source>
<document_content>
declare namespace Pwamap {
  type ShopData = {
    index: number;
    distance?: number;
    'タイムスタンプ': string;
    '緯度': string;
    '経度': string;
    'スポット名': string;
    'カテゴリ': string;
    '紹介文': string;
    '画像': string;
    'URL': string;
    'Instagram': string;
    'Twitter': string;
    'Facebook': string;
    '公式サイト': string;
    '営業時間': string;
    '住所': string;
    '定休日': string;
    '創業年月': string;
  }

  type LngLat = [number, number]
}

</document_content>
</document>
<document index="13">
<source>src\index.tsx</source>
<document_content>
import React from 'react';
import ReactDOM from 'react-dom';
import { HashRouter } from "react-router-dom";
import Container from './Container';
import './index.scss'
import * as serviceWorkerRegistration from './serviceWorkerRegistration';

ReactDOM.render(
  <React.StrictMode>
    <HashRouter>
      <Container />
    </HashRouter>
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA

serviceWorkerRegistration.register();

</document_content>
</document>
<document index="14">
<source>src\Qrcode.tsx</source>
<document_content>
import { useQRCode } from 'next-qrcode';

function Qrcode(props: { url: string }) {

  const { url } = props;
  const { Canvas } = useQRCode();

  return (
    <Canvas
      text={url}
      options={{
        type: 'image/png',
        margin: 0,
        width: 128
      }}
    />
  );
}

export default Qrcode;

</document_content>
</document>
<document index="15">
<source>src\react-app-env.d.ts</source>
<document_content>
/// <reference types="react-scripts" />

</document_content>
</document>
<document index="16">
<source>src\service-worker.ts</source>
<document_content>
/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Any other custom service worker logic can go here.

</document_content>
</document>
<document index="17">
<source>src\serviceWorkerRegistration.ts</source>
<document_content>
// This optional code is used to register a service worker.
// register() is not called by default.

// This lets the app load faster on subsequent visits in production, and gives
// it offline capabilities. However, it also means that developers (and users)
// will only see deployed updates on subsequent visits to a page, after all the
// existing tabs open on the page have been closed, since previously cached
// resources are updated in the background.

// To learn more about the benefits of this model and instructions on how to
// opt-in, read https://cra.link/PWA

const isLocalhost = Boolean(
  window.location.hostname === 'localhost' ||
    // [::1] is the IPv6 localhost address.
    window.location.hostname === '[::1]' ||
    // 127.0.0.0/8 are considered localhost for IPv4.
    window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
);

type Config = {
  onSuccess?: (registration: ServiceWorkerRegistration) => void;
  onUpdate?: (registration: ServiceWorkerRegistration) => void;
};

export function register(config?: Config) {
  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {
    // The URL constructor is available in all browsers that support SW.
    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);
    if (publicUrl.origin !== window.location.origin) {
      // Our service worker won't work if PUBLIC_URL is on a different origin
      // from what our page is served on. This might happen if a CDN is used to
      // serve assets; see https://github.com/facebook/create-react-app/issues/2374
      return;
    }

    window.addEventListener('load', () => {
      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;

      if (isLocalhost) {
        // This is running on localhost. Let's check if a service worker still exists or not.
        checkValidServiceWorker(swUrl, config);

        // Add some additional logging to localhost, pointing developers to the
        // service worker/PWA documentation.
        navigator.serviceWorker.ready.then(() => {
          console.log(
            'This web app is being served cache-first by a service ' +
              'worker. To learn more, visit https://cra.link/PWA'
          );
        });
      } else {
        // Is not localhost. Just register service worker
        registerValidSW(swUrl, config);
      }
    });
  }
}

function registerValidSW(swUrl: string, config?: Config) {
  navigator.serviceWorker
    .register(swUrl)
    .then((registration) => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === 'installed') {
            if (navigator.serviceWorker.controller) {
              // At this point, the updated precached content has been fetched,
              // but the previous service worker will still serve the older
              // content until all client tabs are closed.
              console.log(
                'New content is available and will be used when all ' +
                  'tabs for this page are closed. See https://cra.link/PWA.'
              );

              // Execute callback
              if (config && config.onUpdate) {
                config.onUpdate(registration);
              }
            } else {
              // At this point, everything has been precached.
              // It's the perfect time to display a
              // "Content is cached for offline use." message.
              console.log('Content is cached for offline use.');

              // Execute callback
              if (config && config.onSuccess) {
                config.onSuccess(registration);
              }
            }
          }
        };
      };
    })
    .catch((error) => {
      console.error('Error during service worker registration:', error);
    });
}

function checkValidServiceWorker(swUrl: string, config?: Config) {
  // Check if the service worker can be found. If it can't reload the page.
  fetch(swUrl, {
    headers: { 'Service-Worker': 'script' },
  })
    .then((response) => {
      // Ensure service worker exists, and that we really are getting a JS file.
      const contentType = response.headers.get('content-type');
      if (
        response.status === 404 ||
        (contentType != null && contentType.indexOf('javascript') === -1)
      ) {
        // No service worker found. Probably a different app. Reload the page.
        navigator.serviceWorker.ready.then((registration) => {
          registration.unregister().then(() => {
            window.location.reload();
          });
        });
      } else {
        // Service worker found. Proceed as normal.
        registerValidSW(swUrl, config);
      }
    })
    .catch(() => {
      console.log('No internet connection found. App is running in offline mode.');
    });
}

export function unregister() {
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.ready
      .then((registration) => {
        registration.unregister();
      })
      .catch((error) => {
        console.error(error.message);
      });
  }
}

</document_content>
</document>
<document index="18">
<source>src\setupTests.ts</source>
<document_content>
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom/extend-expect';

</document_content>
</document>
<document index="19">
<source>src\types.d.ts</source>
<document_content>
interface Window {
  geolonia: any;
} 
</document_content>
</document>
<document index="20">
<source>src\App\Category.tsx</source>
<document_content>
import React from "react";
import Select from 'react-select'
import { useNavigate } from 'react-router-dom';
import './Category.scss'

type Props = {
  data: Pwamap.ShopData[];
}

const Content = (props: Props) => {

  const navigate = useNavigate();

  const [categoryList, setCategoryList] = React.useState<string[]>([]);

  React.useEffect(() => {

    let categories: string[] = []

    for (let i = 0; i < props.data.length; i++) {
      const shop = props.data[i];

      if (categories.indexOf(shop['カテゴリ']) === -1) {

        categories.push(shop['カテゴリ'])
      }

    }

    setCategoryList(categories)

  }, [props.data])


  return (
    <>
      <div className="head"></div>
      <div className="category">
        <div className="container">
          <div className="category-item">
            <label htmlFor="category-select">カテゴリから選ぶ</label>
            <Select
              onChange={(e) => {
                if (e) {
                  navigate(`/list?category=${e.value}`);
                }
              }}
              options={
                categoryList.map(category => {
                  return {
                    value: category,
                    label: category
                  }
                })
              }
            />
          </div>

        </div>
      </div>
    </>
  );
};

export default Content;

</document_content>
</document>
<document index="21">
<source>src\App\Home.tsx</source>
<document_content>
/* 
Full Path: /src/App/Home.tsx
Last Modified: 2025-02-28 17:00:00
*/

import React, { useState, useEffect, useCallback } from 'react';
import ReactDOM from 'react-dom';
import Map from './Map';
import Shop from './Shop';
import SearchFeature from './SearchFeature';
import './Home.scss';

type HomeProps = {
  data: Pwamap.ShopData[];
};

const Home: React.FC<HomeProps> = (props) => {
  const [data, setData] = useState<Pwamap.ShopData[]>([]);
  const [selectedShop, setSelectedShop] = useState<Pwamap.ShopData | undefined>(undefined);
  const [filteredShops, setFilteredShops] = useState<Pwamap.ShopData[]>([]);

  // 親コンポーネントからのデータを設定
  useEffect(() => {
    if (props.data.length > 0) {
      setData(props.data);
      setFilteredShops(props.data);
    }
  }, [props.data]);

  // 検索結果を受け取るハンドラ
  const handleSearchResults = useCallback((results: Pwamap.ShopData[]) => {
    setFilteredShops(results);
  }, []);

  // 店舗選択ハンドラ
  const handleSelectShop = useCallback((shop: Pwamap.ShopData) => {
    setSelectedShop(shop);
  }, []);

  // Shop閉じる処理
  const handleCloseShop = useCallback(() => {
    setSelectedShop(undefined);
  }, []);

  return (
    <div className="home">
      <SearchFeature 
        data={data}
        onSelectShop={handleSelectShop}
        onSearchResults={handleSearchResults}
      />
      <Map 
        data={filteredShops} 
        selectedShop={selectedShop}
        onSelectShop={handleSelectShop}
        initialData={props.data}
      />
      {selectedShop &&
        ReactDOM.createPortal(
          <Shop shop={selectedShop} close={handleCloseShop} />,
          document.getElementById('modal-root') as HTMLElement
        )
      }
    </div>
  );
};

export default Home;

</document_content>
</document>
<document index="22">
<source>src\App\Images.tsx</source>
<document_content>
import { useEffect, useState } from 'react'
import { ImageList, ImageListItem } from '@material-ui/core'
import Shop from './Shop'
import './Images.scss'

type Props = {
  data: Pwamap.ShopData[];
}

const Content = (props: Props) => {

  const { data } = props;
  const [validImageList, setValidImageList ] = useState<JSX.Element[]>([]);
  const [shop, setShop] = useState<Pwamap.ShopData | undefined>()

  const popupHandler = (shop: Pwamap.ShopData) => {
    if (shop) {
      setShop(shop)
    }
  }

  const closeHandler = () => {
    setShop(undefined)
  }

  useEffect(() => {

    let imageListItems = []

    for (let i = 0; i < data.length; i++) {
      const item = data[i];

      if (item['画像']) {

        imageListItems.push(
          <ImageListItem
            key={i}
            className="mui-image-list-item"
          >
            <img
              src={item['画像']}
              alt={item['スポット名']}
              loading="lazy"
              onClick={() => popupHandler(item)}
              onError={e => {
                //@ts-ignore
                e.target.parentNode.remove()
              }}
            />
          </ImageListItem>
        )
      }
    }

    setValidImageList(imageListItems)

  }, [data])

  return (
    <>
      <div className="head"></div>
      <div className="images">
        <div className="container">
          <ImageList id="mui-image-list" sx={{ width: "100%", height: "100%" }} cols={2} rowHeight={164}>
            {validImageList}
          </ImageList>
          {shop ?
            <Shop shop={shop} close={closeHandler} />
            :
            <></>
          }
        </div>
      </div>
    </>
  );
};

export default Content;

</document_content>
</document>
<document index="23">
<source>src\App\Links.tsx</source>
<document_content>
import React from "react";
import { FaTwitter, FaInstagram, FaHome, FaFacebook } from 'react-icons/fa';

import './Links.scss'

type Props = {
  data: Pwamap.ShopData;
};

const noop = (e: React.MouseEvent) => {
  e.stopPropagation()
}

const Content = (props: Props) => {

  return (
    <div className="links">
      {props.data['Instagram']?<div className="link"><a href={`https://instagram.com/${props.data['Instagram']}`}><FaInstagram onClick={noop} size="20px" /></a></div>:''}
      {props.data['Twitter']?<div className="link"><a href={`https://twitter.com/${props.data['Twitter']}`}><FaTwitter onClick={noop} size="20px" /></a></div>:''}
      {props.data['Facebook']?<div className="link"><a href={`https://www.facebook.com/${props.data['Facebook']}`}><FaFacebook onClick={noop} size="20px" /></a></div>:''}
      {props.data['公式サイト']?<div className="link"><a href={props.data['公式サイト']}><FaHome onClick={noop} size="20px" /></a></div>:''}
    </div>
  );
};

export default Content;

</document_content>
</document>
<document index="24">
<source>src\App\List.tsx</source>
<document_content>
import React, { useState, useEffect, useMemo } from "react";
import ShopListItem from './ShopListItem';
import Shop from './Shop';
import './List.scss';
import { useSearchParams, useNavigate } from "react-router-dom";
import InfiniteScroll from 'react-infinite-scroll-component';
import { askGeolocationPermission } from '../geolocation';
import * as turf from "@turf/turf";
import { useSwipeable } from "react-swipeable";

// スケルトンローディングコンポーネント
const SkeletonItem = React.memo(() => (
  <div className="shop-list-item skeleton">
    <div className="skeleton-content">
      <div className="skeleton-title"></div>
      <div className="skeleton-text"></div>
    </div>
    <div className="skeleton-image"></div>
  </div>
));

type Props = {
  data: Pwamap.ShopData[];
};

type ShopDataWithDistance = Pwamap.ShopData & { distance?: number };

const sortShopList = async (shopList: Pwamap.ShopData[]): Promise<ShopDataWithDistance[]> => {
  const currentPosition = await askGeolocationPermission();
  if (currentPosition) {
    const from = turf.point(currentPosition);
    const sortingShopList = shopList.map((shop) => {
      const lng = parseFloat(shop['経度']);
      const lat = parseFloat(shop['緯度']);
      if (Number.isNaN(lng) || Number.isNaN(lat)) {
        return shop;
      } else {
        const to = turf.point([lng, lat]);
        const distance = turf.distance(from, to, {units: 'meters'});
        return { ...shop, distance };
      }
    });
    sortingShopList.sort((a, b) => {
      if (typeof a.distance !== 'number' || Number.isNaN(a.distance)) {
        return 1;
      } else if (typeof b.distance !== 'number' || Number.isNaN(b.distance)) {
        return -1;
      } else {
        return (a.distance as number) - (b.distance as number);
      }
    });
    return sortingShopList;
  } else {
    return shopList;
  }
};

const Content = (props: Props) => {

  const [shop, setShop] = useState<Pwamap.ShopData | undefined>();
  const [data, setData] = useState<Pwamap.ShopData[]>(props.data);
  const [list, setList] = useState<Pwamap.ShopData[]>([]);
  const [page, setPage] = useState(10);
  const [hasMore, setHasMore] = useState(true);
  const navigate = useNavigate();

  const [searchParams] = useSearchParams();
  const queryCategory = searchParams.get('category');

  useEffect(() => {
    let isMounted = true;

    const fetchData = async () => {
      let filteredData = props.data;

      if (queryCategory) {
        filteredData = props.data.filter((shop) => {
          return shop['カテゴリ'] === queryCategory;
        });
      }

      const orderBy = process.env.REACT_APP_ORDERBY;

      if (orderBy === 'distance') {
        const sortedData = await sortShopList(filteredData);
        if (isMounted) {
          setList(sortedData.slice(0, page));
          setData(sortedData);
        }
      } else {
        if (isMounted) {
          setList(filteredData.slice(0, page));
          setData(filteredData);
        }
      }
    };

    fetchData();

    return () => {
      isMounted = false;
    };
  }, [props.data, queryCategory, page]);

  const popupHandler = (shop: Pwamap.ShopData) => {
    if (shop) {
      setShop(shop);
    }
  };

  const closeHandler = () => {
    setShop(undefined);
  };

  const loadMore = () => {

    if (list.length >= data.length) {
      setHasMore(false);
      return;
    }

    setList([...list, ...data.slice(page, page + 10)]);
    setPage(page + 10);
  };

  // スワイプハンドラーの設定
  const swipeHandlers = useSwipeable({
    onSwiped: (eventData) => {
      // X方向のスワイプのみを検出し、前の画面に戻る
      if (Math.abs(eventData.deltaX) > Math.abs(eventData.deltaY) && Math.abs(eventData.deltaX) > 50) {
        navigate(-1);
      }
    },
    trackMouse: false,
    preventScrollOnSwipe: false,
  });

  // skeletonLoader を定義して、InfiniteScroll の loader として利用する
  const skeletonLoader = useMemo(() => (
    <div className="skeleton-container">
      {Array(3).fill(0).map((_, index) => (
        <SkeletonItem key={`skeleton-${index}`} />
      ))}
    </div>
  ), []);

  return (
    <div id="shop-list" className="shop-list" {...swipeHandlers}>
      {queryCategory && <div className="shop-list-category">{`カテゴリ：「${queryCategory}」`}</div>}

      <InfiniteScroll
        dataLength={list.length}
        next={loadMore}
        hasMore={hasMore}
        loader={<div className="list-loader" key="loader"></div>}
        scrollableTarget="shop-list"
      >
        {list.length === 0 ? skeletonLoader : 
          list.map((item) => (
            <div key={item.index} className="shop">
              <ShopListItem
                data={item}
                popupHandler={popupHandler}
                queryCategory={queryCategory}
              />
            </div>
          ))
        }
      </InfiniteScroll>
      
      {shop && <Shop shop={shop} close={closeHandler} />}
    </div>
  );
};

export default React.memo(Content);
</document_content>
</document>
<document index="25">
<source>src\App\Map.tsx</source>
<document_content>
// /src/App/Map.tsx
import React from "react";
// @ts-ignore
import geojsonExtent from '@mapbox/geojson-extent';
import toGeoJson from './toGeoJson';
import setCluster from './setCluster';
import SearchFeature from './SearchFeature';

type Props = {
  data: Pwamap.ShopData[];
  selectedShop?: Pwamap.ShopData;
  onSelectShop: (shop: Pwamap.ShopData) => void;
  initialData?: Pwamap.ShopData[];
};

// 新潟県中心の座標（初期表示用フォールバック）
const NIIGATA_CENTER: [number, number] = [138.5, 37.9];
const DEFAULT_ZOOM = 8;

const CSS: React.CSSProperties = {
  width: '100%',
  height: '100%',
  position: 'relative',
};

const hidePoiLayers = (map: any) => {
  const hideLayers = [
    'poi',
    'poi-primary',
    'poi-r0-r9',
    'poi-r10-r24',
    'poi-r25',
    'poi-bus',
    'poi-entrance',
  ];

  for (let i = 0; i < hideLayers.length; i++) {
    const layerId = hideLayers[i];
    map.setLayoutProperty(layerId, 'visibility', 'none');
  }
};

const Content = (props: Props) => {
  const mapNode = React.useRef<HTMLDivElement>(null);
  const [mapObject, setMapObject] = React.useState<any>();
  const [filteredData, setFilteredData] = React.useState<Pwamap.ShopData[]>([]);
  
  // 検索結果を受け取るハンドラー
  const handleSearchResults = (results: Pwamap.ShopData[]) => {
    setFilteredData(results);
  };

  // マーカーをマップに追加
  const addMarkers = (mapObject: any, data: any) => {
    if (!mapObject || data.length === 0) {
      return;
    }

    mapObject.on('render', () => {
      // 既にソースが存在する場合は何もしない
      if (mapObject.getSource('shops')) {
        return;
      }

      hidePoiLayers(mapObject);

      const textColor = '#000000';
      const textHaloColor = '#FFFFFF';

      const geojson = toGeoJson(data);

      mapObject.addSource('shops', {
        type: 'geojson',
        data: geojson,
        cluster: true,
        clusterMaxZoom: 14,
        clusterRadius: 25,
      });

      mapObject.addLayer({
        id: 'shop-points',
        type: 'circle',
        source: 'shops',
        filter: ['all', ['==', '$type', 'Point']],
        paint: {
          'circle-radius': 13,
          'circle-color': '#FF0000',
          'circle-opacity': 0.4,
          'circle-stroke-width': 2,
          'circle-stroke-color': '#FFFFFF',
          'circle-stroke-opacity': 1,
        },
      });

      mapObject.addLayer({
        id: 'shop-symbol',
        type: 'symbol',
        source: 'shops',
        filter: ['all', ['==', '$type', 'Point']],
        paint: {
          'text-color': textColor,
          'text-halo-color': textHaloColor,
          'text-halo-width': 2,
        },
        layout: {
          'text-field': "{スポット名}",
          'text-font': ['Noto Sans Regular'],
          'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
          'text-radial-offset': 0.5,
          'text-justify': 'auto',
          'text-size': 12,
          'text-anchor': 'top',
          'text-max-width': 12,
          'text-allow-overlap': false,
        },
      });

      mapObject.on('mouseenter', 'shop-points', () => {
        mapObject.getCanvas().style.cursor = 'pointer';
      });

      mapObject.on('mouseleave', 'shop-points', () => {
        mapObject.getCanvas().style.cursor = '';
      });

      mapObject.on('mouseenter', 'shop-symbol', () => {
        mapObject.getCanvas().style.cursor = 'pointer';
      });

      mapObject.on('mouseleave', 'shop-symbol', () => {
        mapObject.getCanvas().style.cursor = '';
      });

      mapObject.on('click', 'shop-points', (event: any) => {
        if (!event.features[0].properties.cluster) {
          props.onSelectShop(event.features[0].properties);
        }
      });

      mapObject.on('click', 'shop-symbol', (event: any) => {
        if (!event.features[0].properties.cluster) {
          props.onSelectShop(event.features[0].properties);
        }
      });

      setCluster(mapObject);
    });
  };

  // マップデータが変わったらマーカーを更新
  React.useEffect(() => {
    // データをどちらにするか決める
    const displayData = filteredData.length > 0 ? filteredData : props.data;
    
    addMarkers(mapObject, displayData);
  }, [mapObject, filteredData, props.data]);

  // 地図の表示範囲を調整
  React.useEffect(() => {
    if (!mapObject || props.data.length === 0) {
      return;
    }
    
    // 表示するデータ
    const displayData = filteredData.length > 0 ? filteredData : props.data;
    
    const geojson = toGeoJson(displayData);
    const bounds = geojsonExtent(geojson);

    if (bounds) {
      mapObject.fitBounds(bounds, {
        padding: 50
      });
    }
  }, [mapObject, filteredData, props.data]);

  // 選択された店舗があれば、その位置に地図を移動
  React.useEffect(() => {
    if (!mapObject || !props.selectedShop) {
      return;
    }
    
    const lat = parseFloat(props.selectedShop['緯度']);
    const lng = parseFloat(props.selectedShop['経度']);
    
    if (lat && lng) {
      mapObject.flyTo({
        center: [lng, lat],
        zoom: 17,
        essential: true
      });
    }
  }, [mapObject, props.selectedShop]);

  // 地図の初期化（一度だけ実行）
  React.useEffect(() => {
    // マップノードが無いか、既にマップオブジェクトが存在する場合は何もしない
    if (!mapNode.current || mapObject) {
      return;
    }

    // @ts-ignore
    const { geolonia } = window;

    // 地図を初期化
    const map = new geolonia.Map({
      container: mapNode.current,
      style: 'geolonia/basic',
      center: NIIGATA_CENTER,
      zoom: DEFAULT_ZOOM
    });

    // 地図が読み込まれたときの処理
    const onMapLoad = () => {
      hidePoiLayers(map);
      setMapObject(map);
      
      // ジオロケーションコントロールを追加
      const geolocateControl = new geolonia.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        },
        trackUserLocation: true,
        showUserLocation: true
      });
      
      map.addControl(geolocateControl, 'top-right');
      
      // 少し遅延して位置情報取得
      setTimeout(() => {
        geolocateControl.trigger();
      }, 500);
    };

    // 画面の向きが変わったときのハンドラー
    const orientationChangeHandler = () => {
      map.resize();
    };

    // イベントリスナーを登録
    map.on('load', onMapLoad);
    window.addEventListener('orientationchange', orientationChangeHandler);

    // クリーンアップ関数
    return () => {
      // イベントリスナーを削除
      window.removeEventListener('orientationchange', orientationChangeHandler);
      map.off('load', onMapLoad);
    };
  }, [mapNode, mapObject, props.data]);

  return (
    <div style={CSS}>
      {/* 検索機能 */}
      <div style={{ position: 'absolute', top: 10, left: 10, right: 10, zIndex: 1 }}>
        <SearchFeature 
          data={props.data} 
          onSearchResults={handleSearchResults} 
          onSelectShop={props.onSelectShop} 
        />
      </div>
      
      {/* 地図コンテナ */}
      <div
        ref={mapNode}
        style={CSS}
        data-geolocate-control="off"
        data-marker="off"
        data-gesture-handling="on"
      ></div>
    </div>
  );
};

export default Content;
</document_content>
</document>
<document index="26">
<source>src\App\SearchBar.tsx</source>
<document_content>
import React, { useState, useCallback } from 'react';
import './SearchBar.scss';

type SearchBarProps = {
  onSearch: (query: string) => void;
};

const SearchBar: React.FC<SearchBarProps> = ({ onSearch }) => {
  const [query, setQuery] = useState('');
  
  // デバウンスされた検索処理
  const debouncedSearch = useCallback((value: string) => {
    const timeoutId = setTimeout(() => {
      onSearch(value);
    }, 300);
    return () => clearTimeout(timeoutId);
  }, [onSearch]);
  
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };
  
  return (
    <div className="search-bar-container">
      <input
        type="text"
        className="search-input"
        placeholder="スポットを検索..."
        value={query}
        onChange={handleChange}
        aria-label="検索"
      />
    </div>
  );
};

export default SearchBar;
</document_content>
</document>
<document index="27">
<source>src\App\SearchFeature.tsx</source>
<document_content>
import React, { useState, useEffect, useCallback, useRef } from 'react';
import './SearchFeature.scss';

type SearchFeatureProps = {
  data: Pwamap.ShopData[];
  onSearchResults: (results: Pwamap.ShopData[]) => void;
  onSelectShop: (shop: Pwamap.ShopData) => void;
};

const SearchFeature: React.FC<SearchFeatureProps> = ({ data, onSearchResults, onSelectShop }) => {
  const [query, setQuery] = useState('');
  const [selectedCategory, setSelectedCategory] = useState<string>('');
  const [isOpenNow, setIsOpenNow] = useState(false);
  const [hasParking, setHasParking] = useState(false);
  const [categories, setCategories] = useState<string[]>([]);
  const [results, setResults] = useState<Pwamap.ShopData[]>([]);
  const [showResults, setShowResults] = useState(false);
  const [showCategoryDropdown, setShowCategoryDropdown] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  // クリック外のイベントを監視して、ドロップダウンを閉じる
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setShowCategoryDropdown(false);
      }
    }
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // カテゴリ一覧を作成
  useEffect(() => {
    if (data.length > 0) {
      const uniqueCategories = Array.from(new Set(data.map(shop => shop['カテゴリ']))).filter(Boolean);
      setCategories(uniqueCategories);
    }
  }, [data]);

  // フィルタリング処理
  const filterShops = useCallback(() => {
    let filtered = data;
    console.debug(`フィルタリング開始：全店舗数 ${filtered.length}`);

    // テキスト検索
    if (query.trim() !== '') {
      filtered = filtered.filter(shop => {
        return Object.entries(shop).some(([_, value]) => {
          if (typeof value === 'string') {
            return value.toLowerCase().includes(query.toLowerCase());
          }
          return false;
        });
      });
      console.debug(`テキスト検索後： ${filtered.length} 件`);
    }

    // カテゴリでフィルタリング
    if (selectedCategory) {
      filtered = filtered.filter(shop => shop['カテゴリ'] === selectedCategory);
      console.debug(`カテゴリフィルタ後： ${filtered.length} 件`);
    }

    // 営業中でフィルタリング
    if (isOpenNow) {
      // 現在時刻をJST（UTC+9）に補正して取得
      const now = new Date();
      const utc = now.getTime() + now.getTimezoneOffset() * 60000;
      const jstNow = new Date(utc + 9 * 60 * 60000);
      const currentHour = jstNow.getHours();
      const currentMinute = jstNow.getMinutes();
      const currentTimeMinutes = currentHour * 60 + currentMinute;
      console.debug(`現在のJST時刻: ${currentHour}:${currentMinute.toString().padStart(2, '0')}`);
      const dayOfWeek = ['日', '月', '火', '水', '木', '金', '土'][jstNow.getDay()];

      filtered = filtered.filter(shop => {
        // 定休日チェック：カンマ、全角カンマ、空白で分割してチェック
        if (shop['定休日']) {
          const closedDays = shop['定休日']
            .split(/,|、|\s+/)
            .map(day => day.trim())
            .filter(day => day !== '');
          if (closedDays.some(day => day.includes(dayOfWeek))) {
            console.debug(`店舗[${shop['スポット名']}]：定休日(${dayOfWeek})のため除外`);
            return false;
          }
        }

        // 営業時間チェック（例: "10:00 - 17:00" の形式）
        if (shop['営業時間']) {
          const timeRangeMatch = shop['営業時間'].match(/(\d{1,2}):(\d{2})\s*-\s*(\d{1,2}):(\d{2})/);
          if (timeRangeMatch) {
            const [, startHourStr, startMinuteStr, endHourStr, endMinuteStr] = timeRangeMatch;
            const startHour = parseInt(startHourStr, 10);
            const startMinute = parseInt(startMinuteStr, 10);
            const endHour = parseInt(endHourStr, 10);
            const endMinute = parseInt(endMinuteStr, 10);
            const startTimeMinutes = startHour * 60 + startMinute;
            const endTimeMinutes = endHour * 60 + endMinute;
            
            console.debug(`店舗[${shop['スポット名']}] 営業時間: ${startHour}:${startMinute.toString().padStart(2, '0')} ～ ${endHour}:${endMinute.toString().padStart(2, '0')}、現在: ${currentHour}:${currentMinute.toString().padStart(2, '0')}`);

            // 深夜営業対応（例: 22:00 - 02:00）
            if (endTimeMinutes < startTimeMinutes) {
              // 終了時間が開始時間より前の場合（深夜営業）
              const isOpen = currentTimeMinutes >= startTimeMinutes || currentTimeMinutes <= endTimeMinutes;
              console.debug(`店舗[${shop['スポット名']}]: 深夜営業判定 = ${isOpen ? '営業中' : '営業時間外'}`);
              return isOpen;
            } else {
              // 通常の営業時間
              const isOpen = currentTimeMinutes >= startTimeMinutes && currentTimeMinutes <= endTimeMinutes;
              console.debug(`店舗[${shop['スポット名']}]: 通常営業判定 = ${isOpen ? '営業中' : '営業時間外'}`);
              return isOpen;
            }
          } else {
            console.warn(`店舗[${shop['スポット名']}]：営業時間の形式が不明 (${shop['営業時間']})`);
            // フォーマット不明な場合は営業中でないと判断
            return false;
          }
        }
        
        // 営業時間情報がない場合は営業中でないと判断
        console.debug(`店舗[${shop['スポット名']}]：営業時間情報なし`);
        return false;
      });
      console.debug(`営業時間フィルタ後： ${filtered.length} 件`);
    }

    // 駐車場フィルタリング：1台以上あるもの
    if (hasParking) {
      filtered = filtered.filter(shop => {
        if (!shop['駐車場']) return false;
        const parkingStr = shop['駐車場'].trim();
        const parkingCountMatch = parkingStr.match(/(\d+)/);
        if (parkingCountMatch) {
          const parkingCount = parseInt(parkingCountMatch[1], 10);
          return parkingCount >= 1;
        }
        return parkingStr.includes('有') || parkingStr.includes('あり');
      });
      console.debug(`駐車場フィルタ後： ${filtered.length} 件`);
    }

    console.debug(`最終フィルタ結果： ${filtered.length} 件`);
    setResults(filtered);
    onSearchResults(filtered);
  }, [data, query, selectedCategory, isOpenNow, hasParking, onSearchResults]);

  // フィルター条件が変わったら再フィルタリング
  useEffect(() => {
    filterShops();
  }, [filterShops]);

  // 検索入力ハンドラー
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setQuery(e.target.value);
    setShowResults(e.target.value.trim() !== '');
  };

  // カテゴリ選択ハンドラー
  const handleCategorySelect = (category: string) => {
    setSelectedCategory(category);
    setShowCategoryDropdown(false);
  };

  // 結果アイテムクリックハンドラー
  const handleResultClick = (shop: Pwamap.ShopData) => {
    onSelectShop(shop);
    setShowResults(false);
  };

  return (
    <div className="search-feature">
      <div className="search-input-container">
        <input
          type="text"
          placeholder="スポットを検索..."
          value={query}
          onChange={handleInputChange}
          className="search-input"
        />
      </div>

      <div className="filter-container">
        {/* カスタムドロップダウン */}
        <div className="filter-item category-filter" ref={dropdownRef}>
          <div 
            className={`custom-dropdown-header ${selectedCategory ? 'active' : ''}`}
            onClick={() => setShowCategoryDropdown(!showCategoryDropdown)}
          >
            {selectedCategory === '' ? 'すべて' : selectedCategory}
          </div>
          {showCategoryDropdown && (
            <div className="custom-dropdown-list">
              <div 
                className="custom-dropdown-item"
                onClick={() => handleCategorySelect('')}
              >
                すべて
              </div>
              {categories.map((category) => (
                <div
                  key={category}
                  className="custom-dropdown-item"
                  onClick={() => handleCategorySelect(category)}
                >
                  {category}
                </div>
              ))}
            </div>
          )}
        </div>
        
        <div className="filter-item">
          <button
            className={`filter-button ${isOpenNow ? 'active' : ''}`}
            onClick={() => setIsOpenNow(!isOpenNow)}
          >
            現在営業中
          </button>
        </div>
        
        <div className="filter-item">
          <button
            className={`filter-button ${hasParking ? 'active' : ''}`}
            onClick={() => setHasParking(!hasParking)}
          >
            駐車場有り
          </button>
        </div>
      </div>

      {showResults && (
        <div className="search-results">
          {results.length === 0 ? (
            <div className="no-results">該当する店舗がありません</div>
          ) : (
            <div className="results-list">
              {results.map((shop, index) => (
                <div
                  key={`shop-result-${index}`}
                  className="result-item"
                  onClick={() => handleResultClick(shop)}
                >
                  <div className="result-info">
                    <div className="result-name" style={{ fontSize: '14px', fontWeight: 'bold', color: '#333' }}>
                      {shop['スポット名']}
                    </div>
                    <div className="result-hours" style={{ fontSize: '8pt', fontWeight: '600' }}>
                     営業時間： {shop['営業時間'] ? shop['営業時間'] : '営業時間不明'}
                    </div>
                    <div className="result-closed" style={{ fontSize: '8pt', fontWeight: '600' }}>
                      定休日：{shop['定休日'] ? shop['定休日'] : '定休日不明'}
                    </div>
                    <div className="result-address" style={{ fontSize: '8pt', fontWeight: '600' }}>
                     住所： {shop['住所'] ? shop['住所'] : '住所不明'}
                    </div>
                  </div>
                  <div className="result-image">
                    {shop['画像'] ? (
                      <img
                        src={shop['画像'].startsWith('http') ? shop['画像'] : `/${shop['画像']}`}
                        alt={shop['スポット名']}
                        style={{ width: 'auto', height: '100%', margin: 0, display: 'block' }}
                      />
                    ) : (
                      <div style={{ width: 'auto', height: '100%', background: '#ccc' }}></div>
                    )}
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default SearchFeature;
</document_content>
</document>
<document index="28">
<source>src\App\SearchResultItem.tsx</source>
<document_content>
import React from 'react';
import './SearchResultItem.scss';

type SearchResultItemProps = {
  shop: any; // TypeScriptの警告を回避するためにany型を使用
  onClick: () => void;
};

const SearchResultItem: React.FC<SearchResultItemProps> = ({ shop, onClick }) => {
  // 画像URLの取得
  const image = shop['画像'] || '';
  
  return (
    <div className="search-result-item" onClick={onClick}>
      <div className="item-content">
        <div className="item-name">{shop['スポット名'] || '名称なし'}</div>
        <div className="item-detail">営業時間: {shop['営業時間'] || '情報なし'}</div>
        <div className="item-detail">定休日: {shop['定休日'] || '情報なし'}</div>
        <div className="item-detail">{shop['住所'] || '住所情報なし'}</div>
      </div>
      {image && (
        <div className="item-image-container">
          <img 
            src={image} 
            alt={shop['スポット名'] || '画像'} 
            className="item-image" 
          />
        </div>
      )}
    </div>
  );
};

export default SearchResultItem;
</document_content>
</document>
<document index="29">
<source>src\App\SearchResultsPanel.tsx</source>
<document_content>
import React, { useEffect, useRef } from 'react';
import SearchResultItem from './SearchResultItem';
import './SearchResultsPanel.scss';

type SearchResultsPanelProps = {
  results: Pwamap.ShopData[];
  visible: boolean;
  onSelectShop: (shop: Pwamap.ShopData) => void;
};

const SearchResultsPanel: React.FC<SearchResultsPanelProps> = ({ 
  results, 
  visible, 
  onSelectShop 
}) => {
  const panelRef = useRef<HTMLDivElement>(null);
  
  // 検索バーの幅と位置に合わせる
  useEffect(() => {
    if (!panelRef.current || !visible) return;
    
    const searchBarContainer = document.querySelector('.search-bar-container');
    if (!searchBarContainer) return;
    
    // 検索バーのスタイルを取得して同期
    const searchBarRect = searchBarContainer.getBoundingClientRect();
    const panelElement = panelRef.current;
    
    // 検索バーと同じ幅と左位置を確保
    panelElement.style.width = `${searchBarRect.width}px`;
    panelElement.style.left = `${searchBarRect.left}px`;
  }, [visible, results]);
  
  if (!visible) return null;
  
  return (
    <div 
      className="search-results-panel" 
      ref={panelRef}
    >
      {results.length === 0 ? (
        <div className="no-results">該当する店舗がありません</div>
      ) : (
        <div className="results-list">
          {results.map((shop, index) => (
            <SearchResultItem 
              key={index} 
              shop={shop} 
              onClick={() => onSelectShop(shop)} 
            />
          ))}
        </div>
      )}
    </div>
  );
};

export default SearchResultsPanel;
</document_content>
</document>
<document index="30">
<source>src\App\setCluster.ts</source>
<document_content>
const setCluster = (map: any) => {
  map.addLayer({
    id: 'clusters',
    type: 'circle',
    source: 'shops',
    filter: ['has', 'point_count'],
    paint: {
      'circle-radius': 20,
      'circle-color': '#FF0000',
      'circle-opacity': 1.0,
    },
  })

  map.addLayer({
    id: 'cluster-count',
    type: 'symbol',
    source: 'shops',
    filter: ['has', 'point_count'],
    paint: {
      'text-color': '#FFFFFF',
    },
    layout: {
      'text-field': '{point_count_abbreviated} 件',
      'text-size': 12,
      'text-font': ['Noto Sans Regular'],
    },
  })

  map.on('click', 'clusters', (e: any) => {
    const features = map.queryRenderedFeatures(e.point, { layers: ['clusters'] })
    const clusterId = features[0].properties.cluster_id
    map.getSource('shops').getClusterExpansionZoom(clusterId, (err: any, zoom: number) => {
      if (err)
        return

      map.easeTo({
        center: features[0].geometry.coordinates,
        zoom: zoom,
      })
    })
  })

  map.on('mouseenter', 'clusters', function () {
    map.getCanvas().style.cursor = 'pointer'
  })

  map.on('mouseleave', 'clusters', function () {
    map.getCanvas().style.cursor = ''
  })
}

export default setCluster;

</document_content>
</document>
<document index="31">
<source>src\App\Share.tsx</source>
<document_content>
import React from "react";
import { FacebookShareButton, LineShareButton, TwitterShareButton } from "react-share";
import { FacebookIcon, LineIcon, TwitterIcon } from "react-share";
import config from '../config.json'

import './Share.scss'

const Content = () => {
  const url = window.location.href.replace(/\?.+$/, '').replace(/#.+$/, '')

  return (
    <div className="share">
      <ul>
        <li><a href="/"><TwitterShareButton url={url} hashtags={[`${config.title}`]} title={`${config.title}`}><TwitterIcon size={32} round={true} /></TwitterShareButton></a></li>
        <li><a href="/"><FacebookShareButton url={url} hashtag={`#${config.title}`}><FacebookIcon size={32} round={true} /></FacebookShareButton></a></li>
        <li><a href="/"><LineShareButton url={url} title={`${config.title}`}><LineIcon size={32} round={true} /></LineShareButton></a></li>
      </ul>
    </div>
  );
};

export default Content;

</document_content>
</document>
<document index="32">
<source>src\App\Shop.tsx</source>
<document_content>
import React, { useEffect, useRef, useState, useContext } from "react";
import Links from "./Links";
import "./Shop.scss";
import { AiOutlineClose } from "react-icons/ai";
import { Link } from "react-router-dom";
import { makeDistanceLabelText } from "./distance-label";
import { GeolocationContext } from "../context/GeolocationContext";
import * as turf from "@turf/turf";

type Props = {
  shop: Pwamap.ShopData;
  close: () => void;
};

const SWIPE_THRESHOLD = 80;

const Shop: React.FC<Props> = (props) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [localDistance, setLocalDistance] = useState<number | undefined>(props.shop.distance);
  const currentPosition = useContext(GeolocationContext);

  // アニメーション用: マウント時に .slide-in クラスを付与して右側からスライドイン
  useEffect(() => {
    if (containerRef.current) {
      setTimeout(() => {
        containerRef.current?.classList.add("slide-in");
      }, 10);
    }
  }, []);

  // もしprops.shop.distanceが未定義なら、現在位置からの距離を計算
  useEffect(() => {
    if (localDistance === undefined && currentPosition) {
      const from = turf.point(currentPosition);
      const lng = parseFloat(props.shop["経度"]);
      const lat = parseFloat(props.shop["緯度"]);
      if (!Number.isNaN(lng) && !Number.isNaN(lat)) {
        const to = turf.point([lng, lat]);
        const distance = turf.distance(from, to, { units: 'meters' as 'meters' });
        setLocalDistance(distance);
      } else {
        setLocalDistance(Infinity);
      }
    }
  }, [localDistance, currentPosition, props.shop]);

  // タッチイベント用の座標管理
  const touchStartX = useRef<number | null>(null);
  const touchEndX = useRef<number | null>(null);

  const onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {
    touchEndX.current = null;
    touchStartX.current = e.touches[0].clientX;
  };

  const onTouchEnd = (e: React.TouchEvent<HTMLDivElement>) => {
    touchEndX.current = e.changedTouches[0].clientX;
    handleSwipeGesture();
  };

  // スワイプ判定: 一定以上の横スワイプで閉じる（閉じるボタンと同じ動作）
  const handleSwipeGesture = () => {
    if (touchStartX.current === null || touchEndX.current === null) return;
    const deltaX = touchStartX.current - touchEndX.current;
    if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
      props.close();
    }
  };

  const handleClose = () => {
    props.close();
  };

  const distanceTipText =
    localDistance !== undefined && localDistance !== Infinity
      ? makeDistanceLabelText(localDistance)
      : "距離不明";

  const category = props.shop["カテゴリ"] || "";
  const content = props.shop["紹介文"] || "";
  const spotName = props.shop["スポット名"] || "店名不明";

  const hours = props.shop["営業時間"] || "営業時間不明";
  const closed = props.shop["定休日"] || "定休日不明";
  const address = props.shop["住所"] || "住所不明";
  const tel = props.shop["TEL"];
  const site = props.shop["公式サイト"];

  // 画像データの処理
  const getImages = () => {
    const imageKeys = ['画像', '画像2', '画像3', '画像4', '画像5'];
    return imageKeys
      .map(key => props.shop[key])
      .filter(img => img && img.trim() !== '')
      .map(img => {
        // 既にURLの場合はそのまま使用、ファイル名のみの場合はpublicフォルダからのパスとして扱う
        if (img.startsWith('http')) {
          return img;
        } else {
          return `/${img}`; // publicフォルダからの相対パス
        }
      });
  };

  const images = getImages();

  return (
    <div
      className="shop-single"
      ref={containerRef}
      onTouchStart={onTouchStart}
      onTouchEnd={onTouchEnd}
    >
      <div className="head">
        <button onClick={handleClose}>
          <AiOutlineClose size="16px" color="#FFFFFF" /> 閉じる
        </button>
      </div>
      <div className="container">
        <h2 className="shop-title">{spotName}</h2>

        {/* カテゴリと距離を同じ行で並べる */}
        <div className="tag-box">
          {category && (
            <Link to={`/list?category=${category}`}>
              <span className="category">{category}</span>
            </Link>
          )}
          {distanceTipText && (
            <span className="distance">現在位置から {distanceTipText}</span>
          )}
        </div>

        {/* SNS リンクをカテゴリの下に配置 */}
        <Links data={props.shop} />

        <div className="shop-info-box">
          <div className="info-item">
            <span className="info-label">営業時間:</span> {hours}
          </div>
          <div className="info-item">
            <span className="info-label">定休日:</span> {closed}
          </div>
          <div className="info-item">
            <span className="info-label">住所:</span> {address}
          </div>
        </div>

        {images.length > 0 && (
          <div className="shop-images-grid">
            {images.map((imgUrl, index) => (
              <div key={`image-${index}`} className="shop-image-item">
                <img src={imgUrl} alt={`${spotName} 画像${index + 1}`} className="shop-image" />
              </div>
            ))}
          </div>
        )}

        {content && (
          <p style={{ margin: "24px 0", wordBreak: "break-all" }}>{content}</p>
        )}

        <div className="action-buttons">
          {tel && (
            <a href={`tel:${tel}`} className="action-button phone-button">
              電話で予約する
            </a>
          )}
          {site && (
            <a
              href={site}
              target="_blank"
              rel="noopener noreferrer"
              className="action-button web-button"
            >
              ネットで予約する
            </a>
          )}
        </div>
      </div>
    </div>
  );
};

export default Shop;
</document_content>
</document>
<document index="33">
<source>src\App\ShopListItem.tsx</source>
<document_content>
import { BsChevronCompactRight } from 'react-icons/bs';
import './ShopListItem.scss';
import { Link } from "react-router-dom";
import { makeDistanceLabelText } from "./distance-label";

type Props = {
  data: Pwamap.ShopData;
  popupHandler: Function;
  queryCategory: string | null;
};

const Content = (props: Props) => {
  const clickHandler = () => {
    props.popupHandler(props.data);
  };

  const distanceTipText = props.data.distance !== undefined 
    ? makeDistanceLabelText(props.data.distance)
    : '距離不明';
  const category = props.data['カテゴリ'];
  const image = props.data['画像'];

  const isCategoryPage = props.queryCategory ? true : false;

  return (
    <div className="shop-link">
      <h2 className="shop-title" style={{ wordBreak: "break-all" }} onClick={clickHandler}>
        {props.data['スポット名']}
      </h2>
      <div className='tag-box'>
        {
          !isCategoryPage &&
          <span className="nowrap">
            <Link to={`/list?category=${category}`}>
              <span className="category">{category}</span>
            </Link>
          </span>
        }
        <span className="nowrap">
          <span className="distance">現在位置から {distanceTipText}</span>
        </span>
      </div>
      <div style={{ margin: "10px 10px 10px 0" }}>
        { image && <img src={image} alt={props.data['スポット名']} onClick={clickHandler}/> }
      </div>
      <div className="right" onClick={clickHandler}>
        <BsChevronCompactRight size="40px" color="#CCCCCC" />
      </div>
    </div>
  );
};

export default Content;

</document_content>
</document>
<document index="34">
<source>src\App\Tabbar.tsx</source>
<document_content>
import React from "react";
import { Link } from "react-router-dom";
import './Tabbar.scss'

import { FaList, FaHome, FaCamera } from "react-icons/fa"
import { AiOutlineAppstore } from "react-icons/ai"

const Content = () => {
  return (
    <div className="tabbar">
      <ul>
        <li><Link to="/"><div className="icon"><FaHome /></div><div className="text">ホーム</div></Link></li>
        <li><Link to="/list"><div className="icon"><FaList /></div><div className="text">一覧</div></Link></li>
        <li><Link to="/images"><div className="icon"><FaCamera /></div><div className="text">写真から探す</div></Link></li>
        <li><Link to="/about"><div className="icon"><AiOutlineAppstore /></div><div className="text">マップについて</div></Link></li>
      </ul>
    </div>
  );

};

export default Content;

</document_content>
</document>
<document index="35">
<source>src\App\toGeoJson.ts</source>
<document_content>
type Geometry = {
  type: string;
  coordinates: number[]
}

type featureProperties = {
  [key: string]: string;
}

type Feature = {
  type: string;
  geometry: Geometry;
  properties: featureProperties
}

type itemObject = {
  [key: string]: any;
}

type GeoJSON = {
  type: string;
  features: Feature[]
}

const toGeoJson = (data: any) => {
  const geojson = {
    type: "FeatureCollection",
    features: []
  } as GeoJSON

  for (const id in data) {
    const item = data[id] as itemObject

    if (!item['経度'] || !item['緯度'] || !item['スポット名']) {
      return;
    }

    const feature = {
      type: "Feature",
      geometry: {
        type: "Point",
        coordinates: [Number(item['経度']), Number(item['緯度'])]
      },
      properties: {_id: id}
    } as Feature

    for (let i = 0; i < Object.keys(item).length; i++) {
      const key = Object.keys(item)[i]
      feature.properties[key] = item[key]
    }

    geojson.features.push(feature)
  }

  return geojson
}

export default toGeoJson;

</document_content>
</document>
<document index="36">
<source>src\context\GeolocationContext.tsx</source>
<document_content>
/* 
Full Path: /src/context/GeolocationContext.tsx
Last Modified: 2025-02-28 17:40:00
*/

import React, { createContext, useState, useEffect, ReactNode } from 'react';
import { askGeolocationPermission } from '../geolocation';

export type LngLat = [number, number] | null;

export const GeolocationContext = createContext<LngLat>(null);

export const GeolocationProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [location, setLocation] = useState<LngLat>(null);

  useEffect(() => {
    askGeolocationPermission()
      .then((pos) => {
        if (pos) {
          setLocation(pos);
        }
      })
      .catch((error) => {
        console.warn("Failed to get geolocation", error);
      });
  }, []);

  return (
    <GeolocationContext.Provider value={location}>
      {children}
    </GeolocationContext.Provider>
  );
};

</document_content>
</document>
<document index="37">
<source>src\lib\table2json.ts</source>
<document_content>
import zen2han from "./zen2han";

const table2json = (table: Array<Array<string>>) => {
  const header = table[0]
  const records = table.slice(1)

  return records.map((record: Array<string>) => {

    const properties = header.reduce((prev: any, column: any) => {
      const value = record[header.indexOf(column)];
      prev[column] = zen2han(value || '');
      return prev;
    }, {});
    return properties;
  });

}

export default table2json;

</document_content>
</document>
<document index="38">
<source>src\lib\zen2han.ts</source>
<document_content>
const zen2han = (str: string) => {
  return str.replace(/[！-～]/g, function (s: string) {
    return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
  }).replace(/　/g, ' ');
}

export default zen2han;

</document_content>
</document>
</documents>
